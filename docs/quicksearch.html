<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"baseProxy.js.html":{"id":"baseProxy.js.html","title":"Source: baseProxy.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: baseProxy.js &quot;use strict&quot;; /** * Base proxy. * * @class * @abstract * @name BaseProxy * @arg {object} [opts] - Options. * @arg {?number} [opts.speed=null] - Proxy speed, kb/s. * @arg {?number} [opts.reqSpeed=null] - Requests speed, kb/s. * @arg {?number} [opts.resSpeed=null] - Responses speed, kb/s. * @arg {boolean} [opts.useCache=false] - Flag to use cache middleware. * @arg {number} [opts.reconnect=0] - Number of times reconnect to remote * side, if it breaks connection. * @arg {timeout} [opts.timeout=60000] - Time to wait remote side response, ms. * @arg {port} [opts.port=0] - Port. Default is random. */ var _ = require(&quot;lodash&quot;); var U = require(&quot;glace-utils&quot;); var BaseProxy = function (opts) { opts = U.defVal(opts, {}); this.isRunning = false; this.reqSpeed = U.defVal(opts.reqSpeed, opts.speed); this.resSpeed = U.defVal(opts.resSpeed, opts.speed); this.responsesData = null; this.useCache = U.defVal(opts.useCache, false); this._reconnect = U.defVal(opts.reconnect, 0); this._timeout = U.defVal(opts.timeout, 60000); this._port = U.defVal(opts.port, 0); this._proxy = null; }; /** * Gets port number. * * @method * @return {number} Proxy port number. * @throws {Error} If port number is not defined and will be chosen randomly. */ BaseProxy.prototype.getPort = function () { if (this._port === 0) throw Error( &quot;Port is not defined and will be chosen randomly on proxy start&quot;); return this._port; }; /** * Sets proxy speed. * * @method * @arg {number|object} speed - Proxy speed, kb/s. * @arg {?number} [speed.req] - Requests speed, kb/s. * @arg {?number} [speed.res] - Responses speed, kb/s. */ BaseProxy.prototype.setSpeed = function (speed) { if (_.isNumber(speed)) { this.reqSpeed = this.resSpeed = speed; } else { if (speed.req !== undefined) this.reqSpeed = speed.req; if (speed.res !== undefined) this.resSpeed = speed.res; }; }; /** * Resets proxy speed. * * @method */ BaseProxy.prototype.resetSpeed = function () { this.reqSpeed = this.resSpeed = null; }; /** * Starts to measure responses and gather information of them. * * @method */ BaseProxy.prototype.measureResponses = function () { this.responsesData = []; }; /** * Disables responses measurement. * * @method */ BaseProxy.prototype.unmeasureResponses = function () { this.responsesData = null; }; /** * Gets responses data. * * @method */ BaseProxy.prototype.getResponsesData = function () { if (this.responsesData === null) return null; return _.cloneDeep(this.responsesData); }; /** * Starts proxy. * * @method */ BaseProxy.prototype.start = function () { throw new Error(&quot;Should be implemented in derived class&quot;); }; /** * Stops proxy server. * * @method */ BaseProxy.prototype.stop = function () { throw new Error(&quot;Should be implemented in derived class&quot;); }; module.exports = BaseProxy; × Search results Close "},"commands.js.html":{"id":"commands.js.html","title":"Source: commands.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: commands.js &quot;use strict&quot;; /** * Creates commands instance. * * @class * @name Commands * @classdesc Aggregates commands to manage `GlaceJS` proxy. * @arg {object} config - Commands config. * @arg {object} [opts] - Commands options. * @arg {function} [opts.logger] - Commands logger. Default is system logger. * @arg {boolean} [opts.colored=false] - Flag to use ANSI color in log message. * @arg {object} [opts.GlobalProxy] - Global proxy class. * @arg {object} [opts.HttpProxy] - HTTP proxy class. * @arg {object} [opts.isRunning] - Function to detect is process launched. */ var fs = require(&quot;fs&quot;); var url = require(&quot;url&quot;); require(&quot;colors&quot;); var _ = require(&quot;lodash&quot;); var chromeLauncher = require(&quot;chrome-launcher&quot;); var fse = require(&quot;fs-extra&quot;); var isRunning = require(&quot;is-running&quot;); var temp = require(&quot;temp&quot;).track(); var U = require(&quot;glace-utils&quot;); var cache = require(&quot;./middleware/cache&quot;); var GlobalProxy = require(&quot;./globalProxy&quot;); var HttpProxy = require(&quot;./httpProxy&quot;); var LOG = U.logger; var Commands = function (config, opts) { this._config = config; opts = U.defVal(opts, {}); this._log = U.defVal(opts.logger, LOG.info.bind(LOG)); this._coloredLog = U.defVal(opts.colored, false); this._chrome = null; this._httpProxy = null; this._globalProxy = null; this.__GlobalProxy = U.defVal(opts.GlobalProxy, GlobalProxy); this.__HttpProxy = U.defVal(opts.HttpProxy, HttpProxy); this.__isRunning = U.defVal(opts.isRunning, isRunning); this.__chromeLauncher = U.defVal(opts.chromeLauncher, chromeLauncher); this.__fs = U.defVal(opts.fs, fs); this.__fse = U.defVal(opts.fse, fse); this.__cache = U.defVal(opts.cache, cache); }; module.exports = Commands; /** * Command to set proxied URL. * * @async * @method * @return {Promise} */ Commands.prototype.setProxiedUrl = async function (proxiedUrl) { this._config.web.url = proxiedUrl; if (this._isHttpProxyLaunched()) { this._httpProxy.setUrl(proxiedUrl); }; if (this._isChromeLaunched()) return await this.restartChrome(); return true; }; /** * Command to launch HTTP proxy. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if HTTP proxy was launched. `false` if * command can't be executed. Causes to not launch HTTP proxy: * - HTTP proxy is launched already. * - Proxied URL isn't specified. */ Commands.prototype.launchHttpProxy = async function () { var msg; if (this._isHttpProxyLaunched()) { msg = &quot;HTTP proxy is launched already&quot;; if (this._coloredLog) msg = msg.red; this._log(msg); return false; }; if (!this._config.web.url) { msg = &quot;HTTP proxy isn't launched because proxied URL is missed&quot;; if (this._coloredLog) msg = msg.red; this._log(msg); return false; }; this._httpProxy = this._httpProxy || new this.__HttpProxy({ port: this._config.proxy.port, timeout: this._config.proxy.timeout, reconnect: this._config.proxy.reconnect, useCache: this._config.cache.use, url: this._config.web.url, speed: this._config.proxy.speed, }); return this._httpProxy .start() .then(() =&gt; { if (this._coloredLog) { msg = `HTTP proxy is started on host ${U.hostname.cyan} ` + `and port ${this._httpProxy._port.toString().yellow}`; } else { msg = `HTTP proxy is started on host '${U.hostname}' and ` + `port '${this._httpProxy._port}'`; }; this._log(msg); }) .then(() =&gt; { if (this._isChromeLaunched()) return this.restartChrome(); }) .then(() =&gt; true); }; /** * Command to stop HTTP proxy. * * @async * @method * @arg {object} [opts] - Options. * @arg {boolean} [opts.restartChrome=true] - Restart chrome. * @return {Promise&lt;boolean&gt;} `true` if HTTP proxy was stopped. `false` if * command can't be executed. Causes to not stop HTTP proxy: * - HTTP proxy isn't launched yet. */ Commands.prototype.stopHttpProxy = async function (opts) { if (!this._isHttpProxyLaunched()) { var msg = &quot;HTTP proxy isn't launched yet&quot;; if (this._coloredLog) msg = msg.red; this._log(msg); return false; }; opts = U.defVal(opts, {}); var restartChrome = U.defVal(opts.restartChrome, true); this._httpProxy.stop(); if (restartChrome &amp;&amp; this._isChromeLaunched()) await this.restartChrome(); return true; }; /** * Command to restart HTTP proxy. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if HTTP proxy was restarted. `false` if * command can't be executed. Causes to not restart HTTP proxy are the same as * for command to launch HTTP proxy. */ Commands.prototype.restartHttpProxy = function() { return this .stopHttpProxy({ restartChrome: false }) .then(() =&gt; this.launchHttpProxy()); }; /** * Command to launch global transparent proxy. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if global transparent proxy isn't * launched. `false` if command can't be executed. Causes to not launch * global transparent proxy: * - Global transparent proxy is launched already. */ Commands.prototype.launchGlobalProxy = function () { var msg; if (this._isGlobalProxyLaunched()) { msg = &quot;Global transparent proxy is launched already&quot;; if (this._coloredLog) msg = msg.red; this._log(msg); return false; }; this._globalProxy = this._globalProxy || new this.__GlobalProxy({ port: this._config.proxy.globalPort, timeout: this._config.proxy.timeout, reconnect: this._config.proxy.reconnect, installCertificate: this._config.proxy.installCertificate, sslCaDir: this._config.proxy.sslCaDir, useCache: this._config.cache.use, speed: this._config.proxy.speed, }); return this._globalProxy .start() .then(() =&gt; { if (this._coloredLog) { msg = &quot;Global transparent proxy is started on &quot; + `${U.hostname.cyan} and port ` + `${this._globalProxy.getPort().toString().yellow}`; } else { msg = &quot;Global transparent proxy is started on host &quot; + `'${U.hostname}' and port '${this._globalProxy.getPort()}'`; }; this._log(msg); }) .then(() =&gt; { if (this._isChromeLaunched()) return this.restartChrome(); }) .then(() =&gt; true); }; /** * Command to stop global transparent proxy. * * @async * @method * @arg {object} [opts] - Options. * @arg {boolean} [opts.restartChrome=true] - Restart chrome. * @return {Promise&lt;boolean&gt;} `true` if global transparent proxy was stopped. * `false` if command can't be executed. Causes to not stop global transparent * proxy: * - Global transparent proxy isn't launched yet. */ Commands.prototype.stopGlobalProxy = async function (opts) { if (!this._isGlobalProxyLaunched()) { var msg = &quot;Global transparent proxy isn't launched yet&quot;; if (this._coloredLog) msg = msg.red; this._log(msg); return false; }; opts = U.defVal(opts, {}); var restartChrome = U.defVal(opts.restartChrome, true); this._globalProxy.stop(); if (restartChrome &amp;&amp; this._isChromeLaunched()) await this.restartChrome(); return true; }; /** * Command to restart global transparent proxy. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if global transparent proxy was restarted. * `false` if command can't be executed. Causes to not restart global * transparent proxy are the same as for command to launch global * transparent proxy. */ Commands.prototype.restartGlobalProxy = function() { return this .stopGlobalProxy({ restartChrome: false }) .then(() =&gt; this.launchGlobalProxy()); }; /** * Command to launch chrome browser. * * @async * @method * @arg {object} [opts] - Options. * @arg {string[]} [opts.chromeOpts=[]] - Chrome options list. * @return {Promise&lt;boolean&gt;} `true` if chrome browser was launched. `false` * if command can't be executed. Causes to not launch chrome browser: * - HTTP proxy isn't launched yet. * - Chrome browser is launched already. */ Commands.prototype.launchChrome = async function (opts) { opts = U.defVal(opts, {}); var chromeOpts = U.defVal(opts.chromeOpts, []); if (this._isChromeLaunched()) { var msg = &quot;Chrome browser is launched already&quot;; if (this._coloredLog) msg = msg.red; this._log(msg); return false; }; var chromeFlags = [ &quot;start-maximized&quot;, &quot;disable-infobars&quot;, &quot;enable-precise-memory-info&quot;, &quot;disable-translate&quot;, ]; var opt; for (opt of chromeOpts) { if (!isOptPresent(opt, chromeFlags)) chromeFlags.push(opt); }; if (this._config.chrome.incognito &amp;&amp; !isOptPresent(&quot;incognito&quot;, chromeFlags)) { chromeFlags.push(&quot;incognito&quot;); }; if (this._isGlobalProxyLaunched()) { var proxyOpts = [ &quot;ignore-certificate-errors&quot;, `proxy-server=${U.hostname}:${this._globalProxy.getPort()}`, `proxy-bypass-list=localhost,127.0.0.1,${U.hostname}`, ]; for (opt of proxyOpts) { if (!isOptPresent(opt, chromeFlags)) chromeFlags.push(opt); }; }; for (var i = 0; i &lt; chromeFlags.length; i++) { if (!chromeFlags[i].startsWith(&quot;-&quot;)) { chromeFlags[i] = &quot;--&quot; + chromeFlags[i]; }; }; var profileDir = temp.path(); fse.mkdirsSync(profileDir); return this.__chromeLauncher.launch({ startingUrl: this._chromeUrl(), userDataDir: profileDir, chromeFlags: chromeFlags, handleSIGINT: true, }).then(chrome =&gt; { this._chrome = chrome; var msg; if (this._coloredLog) { msg = &quot;Chrome is launched with PID &quot; + `${chrome.pid.toString().yellow}`; } else { msg = `Chrome is launched with PID '${chrome.pid}'`; } this._log(msg); LOG.info(&quot;Chrome PID&quot;, chrome.pid); LOG.info(&quot;Chrome debugging port&quot;, chrome.port); LOG.info(&quot;Chrome profile&quot;, profileDir); return true; }); }; /** * Command to close chrome browser. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if chrome browser was closed. `false` if * command can't be executed. Causes to not close chrome browser: * - Chrome browser isn't launched yet. */ Commands.prototype.closeChrome = async function () { if (!this._isChromeLaunched()) { var msg = &quot;Chrome browser isn't launched yet&quot;; if (this._coloredLog) msg = msg.red; this._log(msg); return false; }; await this._chrome.kill(); this._chrome = null; return true; }; /** * Command to restart chrome browser. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if chrome browser was restarted. `false` * if command can't be executed. Causes to not restart chrome browser are the * the same as for command to launch chrome browser. */ Commands.prototype.restartChrome = function () { return this.closeChrome().then(() =&gt; this.launchChrome()); }; /** * Command to set proxy speed. * * @async * @method * @arg {number} speed - Proxy speed, kb/s. * @arg {?number} [speed.req] - Requests speed, kb/s. * @arg {?number} [speed.res] - Responses speed, kb/s. * @return {Promise&lt;boolean&gt;} `true` if proxy speed was set. `false` if * command can't be executed. Causes to not set proxy speed: * - HTTP proxy isn't launched. */ Commands.prototype.setProxySpeed = async function (speed) { if (!this._checkProxy()) return false; if (this._httpProxy) { this._httpProxy.setSpeed(speed); }; if (this._globalProxy) { this._globalProxy.setSpeed(speed); }; return true; }; /** * Command to reset proxy speed. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if proxy speed was reset. `false` if * command can't be executed. Causes to not reset proxy speed: * - HTTP proxy isn't launched. */ Commands.prototype.resetProxySpeed = async function () { if (!this._checkProxy()) return false; if (this._httpProxy) { this._httpProxy.resetSpeed(); }; if (this._globalProxy) { this._globalProxy.resetSpeed(); }; return true; }; /** * Command to enable proxy cache. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if proxy cache wasn't enabled. `false` if * command can't be executed. Causes to not enable proxy cache: * - HTTP proxy isn't launched. */ Commands.prototype.enableProxyCache = async function () { if (!this._checkProxy()) return false; if (this._httpProxy) { this._httpProxy.useCache = true; }; if (this._globalProxy) { this._globalProxy.useCache = true; }; return true; }; /** * Command to disable proxy cache. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` if proxy cache wasn't disabled. `false` * if command can't be executed. Causes to not disable proxy cache: * - HTTP proxy isn't launched. */ Commands.prototype.disableProxyCache = async function () { if (!this._checkProxy()) return false; if (this._httpProxy) { this._httpProxy.useCache = false; }; if (this._globalProxy) { this._globalProxy.useCache = false; }; return true; }; /** * Command to clear proxy cache. * * @async * @method * @return {Promise&lt;boolean&gt;} `true` when cache will be cleared. */ Commands.prototype.clearProxyCache = async function () { if (this.__fs.existsSync(this._config.cache.folder)) { this.__fse.removeSync(this._config.cache.folder); }; await this.__cache.init({ force: true }); return true; }; /** * Helper to check whether any proxy is launched. * * @method * @protected * @return {boolean} `true` if proxy exists and launched, `false` otherwise. */ Commands.prototype._checkProxy = function () { if ((this._isHttpProxyLaunched()) || (this._isGlobalProxyLaunched())) return true; var msg = &quot;No one of http or global proxy isn't launched yet&quot;; if (this._coloredLog) msg = msg.red; this._log(msg); return false; }; /** * Helper to define whether chrome is launched. * * @method * @protected * @return {boolean} */ Commands.prototype._isChromeLaunched = function () { return !!(this._chrome &amp;&amp; this.__isRunning(this._chrome.pid)); }; /** * Helper to get URL to open in chrome browser. If HTTP proxy is launched, * it will return proxy URL. * * @method * @protected * @return {string} URL to open chrome. */ Commands.prototype._chromeUrl = function () { var result; if (this._isHttpProxyLaunched()) { result = _.trim( this._httpProxy.url + url.parse(this._config.web.url).pathname, &quot;/&quot;); } else { result = this._config.web.url; }; return result; }; /** * Helper to define whether http proxy is running. * * @method * @protected * @return {boolean} */ Commands.prototype._isHttpProxyLaunched = function () { return !!(this._httpProxy &amp;&amp; this._httpProxy.isRunning); }; /** * Helper to define whether global proxy is running. * * @method * @protected * @return {boolean} */ Commands.prototype._isGlobalProxyLaunched = function () { return !!(this._globalProxy &amp;&amp; this._globalProxy.isRunning); }; /** * Helper to define whether chrome option is present in options list. * * @ignore * @function * @arg {string} opt - Checking option. * @arg {string[]} opts - List of options. * @return {boolean} */ var isOptPresent = (opt, opts) =&gt; { var optStart = opt.split(&quot;=&quot;)[0]; for (var o of opts) { if (o.split(&quot;=&quot;)[0] === optStart) return true; }; return false; }; × Search results Close "},"fixtures.js.html":{"id":"fixtures.js.html","title":"Source: fixtures.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: fixtures.js &quot;use strict&quot;; /** * `Proxy` fixtures. * * @module */ /** * Fixture to launch http proxy. * * @global * @function * @arg {function} func - Test funciton. */ global.fxHttpProxy = func =&gt; { var isStarted; before(async () =&gt; { isStarted = await SS.startHttpProxy(); }); func(); after(async () =&gt; { if (!isStarted) return; await SS.stopHttpProxy(); }); }; /** * Fixture to launch http proxy. * * @global * @function * @arg {function} func - Test funciton. */ global.fxGlobalProxy = func =&gt; { var isStarted; before(async () =&gt; { isStarted = await SS.startGlobalProxy(); }); func(); after(async () =&gt; { if (!isStarted) return; await SS.stopGlobalProxy(); }); }; × Search results Close "},"globalProxy.js.html":{"id":"globalProxy.js.html","title":"Source: globalProxy.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: globalProxy.js &quot;use strict&quot;; /** * Creates new instance of `GlobalProxy`. * * @class * @name GlobalProxy * @classdesc - Contains methods to run and manage global transparent proxy. * @arg {object} [opts] - global proxy options * @arg {number} [opts.port=0] - global proxy port * @arg {number} [opts.timeout=0] - global proxy timeout * @arg {boolean} [opts.installCertificate=false] - flag to install global * proxy certificate as trusted in order to manage `https` connection or no * @arg {?string} [opts.rootPath] - Folder where proxy starts in order to * generate self-signed certificate. By default is `current work directory`. * @arg {boolean} [opts.useCache=false] - flag to cache and take from cache responses */ var fs = require(&quot;fs&quot;); var path = require(&quot;path&quot;); var util = require(&quot;util&quot;); var expect = require(&quot;chai&quot;).expect; const getPort = require(&quot;get-port&quot;); var MitmProxy = require(&quot;http-mitm-proxy&quot;).Proxy; var spawn = require(&quot;cross-spawn&quot;); var U = require(&quot;glace-utils&quot;); var BaseProxy = require(&quot;./baseProxy&quot;); var cache = require(&quot;./middleware/cache&quot;); var middleware = require(&quot;./middleware&quot;); var LOG = U.logger; var _onError = MitmProxy.prototype._onError; /** * Patch mitm proxy error processing, in order to avoid default response * finalizing on reconnect. * * @ignore */ MitmProxy.prototype._onError = function (kind, ctx, err) { if (!ctx) return _onError.apply(this, arguments); var req = ctx.clientToProxyRequest; if (req._reconnect &gt; 0 &amp;&amp; !req.socket.destroyed) { this.onErrorHandlers.forEach(function(handler) { return handler(ctx, err, kind); }); } else { _onError.apply(this, arguments); }; }; var GlobalProxy = function (opts) { opts = U.defVal(opts, {}); BaseProxy.call(this, opts); this._installCertificate = U.defVal(opts.installCertificate, false); this._sslCaDir = U.defVal(opts.sslCaDir, path.resolve(U.cwd, &quot;.http-mitm-proxy&quot;)); this._certificatePath = path.resolve(this._sslCaDir, &quot;certs&quot;, &quot;ca.pem&quot;); this._proxy = new MitmProxy(); this._proxy.onError((ctx, err) =&gt; { if (!ctx) { LOG.error(err); return; } var req = ctx.clientToProxyRequest; if (req._reconnect &gt; 0 &amp;&amp; !req.socket.destroyed) { LOG.warn(&quot;Request reconnected&quot;, U.getReqKey(req)); req._reconnect--; this._proxy._onHttpServerRequest(ctx.isSSL, ctx.clientToProxyRequest, ctx.proxyToClientResponse); } else { LOG.error(U.getReqKey(req), err); }; }); this._proxy.onRequest(async (ctx, callback) =&gt; { this.req = ctx.clientToProxyRequest; if (this.req._reconnect === undefined) { this.req._reconnect = this._reconnect; }; this.res = ctx.proxyToClientResponse; for (var mw of middleware) if (await mw.call(this)) return; delete this.req; delete this.res; return callback(); }); // TODO not sure that it works reliable this._proxy.onRequestData((ctx, chunk, callback) =&gt; { if (ctx.clientToProxyRequest.body) { chunk = new Buffer(&quot;&quot;); }; return callback(null, chunk); }); this._proxy.onResponse((ctx, callback) =&gt; { if (ctx.clientToProxyRequest.body) { ctx.proxyToServerRequest.end(ctx.clientToProxyRequest.body); }; return callback(null); }); }; util.inherits(GlobalProxy, BaseProxy); module.exports = GlobalProxy; /** * Starts global proxy if it's not started yet. * * @async * @method */ GlobalProxy.prototype.start = async function () { if (this.isRunning) return; if (!this._port) this._port = await getPort(); return new Promise((resolve, reject) =&gt; { this._proxy.listen({ port: this._port, silent: true, sslCaDir: this._sslCaDir, timeout: this._timeout }, err =&gt; { if (err) reject(err); resolve(); }); }).then(() =&gt; cache.init()).then(() =&gt; { this.isRunning = true; if (this._installCertificate) { if (process.platform !== &quot;win32&quot;) { throw new Error(&quot;For your platform certificate&quot; + &quot;installation isn't implemented&quot;); }; expect(fs.existsSync(this._certificatePath), `Proxy certificate ${this._certificatePath} is absent`) .to.be.true; var proc = spawn.sync(&quot;certutil&quot;, [ &quot;-addstore&quot;, &quot;-enterprise&quot;, &quot;-f&quot;, &quot;Root&quot;, this._certificatePath ]); if (proc.status !== 0) { throw new Error( &quot;Can't install proxy certificate as trusted:\\n&quot; + proc.stdout.toString()); }; }; }); }; /** * Stops global proxy if it's not stopped yet. * * @method */ GlobalProxy.prototype.stop = function () { if (!this.isRunning) return; this._proxy.close(); this.isRunning = false; }; × Search results Close "},"httpProxy.js.html":{"id":"httpProxy.js.html","title":"Source: httpProxy.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: httpProxy.js &quot;use strict&quot;; /** * HTTP Proxy. * * @class * @name HttpProxy * @arg {object} opts - Proxy options. * @arg {string} opts.url - URL which should be proxied. * them from cache. */ var http = require(&quot;http&quot;); var https = require(&quot;https&quot;); var url = require(&quot;url&quot;); var util = require(&quot;util&quot;); require(&quot;colors&quot;); var expect = require(&quot;chai&quot;).expect; var express = require(&quot;express&quot;); var httpProxy = require(&quot;http-proxy&quot;); var U = require(&quot;glace-utils&quot;); var BaseProxy = require(&quot;./baseProxy&quot;); var cache = require(&quot;./middleware/cache&quot;); var middleware = require(&quot;./middleware&quot;); var LOG = U.logger; var HttpProxy = function (opts) { BaseProxy.call(this, opts); this.url = null; this._initUrl = null; this._server = null; this._proxyOptions = {}; this._proxy = httpProxy.createProxyServer(); this._proxy.on(&quot;proxyReq&quot;, (proxyReq, req) =&gt; { if (req.body) proxyReq.end(req.body); }); this._proxy.on(&quot;error&quot;, this.__onError.bind(this)); this.setUrl(opts.url); var app = express(); app.use(async (req, res) =&gt; { this.req = req; if (this.req._reconnect === undefined) { this.req._reconnect = this._reconnect; }; this.res = res; for (var mw of middleware) if (await mw.call(this)) return; delete this.req; delete this.res; this._proxy.web(req, res, this._proxyOptions); }); this._server = http.createServer(app); }; util.inherits(HttpProxy, BaseProxy); module.exports = HttpProxy; /** * Sets proxied URL. * * @method * @arg {string} targetUrl - URL which should be proxied. */ HttpProxy.prototype.setUrl = function (targetUrl) { this._initUrl = targetUrl; var parsedUrl = url.parse(targetUrl); expect([&quot;http:&quot;, &quot;https:&quot;], &quot;Unsupported protocol&quot;).include(parsedUrl.protocol); // FIXME work around bug in `node-http-proxy`: https://github.com/nodejitsu/node-http-proxy/pull/1074 this._proxy.options = { proxyTimeout: this._timeout }; if (parsedUrl.protocol === &quot;https:&quot;) { this._proxyOptions = { target: &quot;https://&quot; + parsedUrl.host, agent: https.globalAgent, headers: { host: parsedUrl.hostname }, }; } else { this._proxyOptions = { target: { host: parsedUrl.hostname, port: parsedUrl.port, }, }; }; }; /** * Starts proxy server if it’s not started yet. * * @async * @method * @return {Promise&lt;string&gt;} - Proxy URL. */ HttpProxy.prototype.start = function () { return new Promise((resolve, reject) =&gt; { if (this.isRunning) return resolve(); this._server.listen(this._port, err =&gt; { if (err) return reject(err); this._port = this._server.address().port; this.url = `http://${U.hostname}:${this._port}`; this.isRunning = true; resolve(); }); }) .then(() =&gt; cache.init()) .then(() =&gt; this.url); }; /** * Stops proxy server if it’s not stopped yet. * * @method */ HttpProxy.prototype.stop = function () { if (!this.isRunning) return; this._server.close(); this._proxy.close(); this.proxyUrl = null; this.isRunning = false; }; /** * Helper to be called on proxy error to retry request. * * @ignore * @method * @protected * @arg {Error} err * @arg {Request} req * @arg {Response} res */ HttpProxy.prototype.__onError = function (err, req, res) { if (req._reconnect &gt; 0 &amp;&amp; !req.socket.destroyed) { LOG.warn(&quot;Request reconnected&quot;, U.getReqKey(req)); req._reconnect--; this._proxy.web(req, res, this._proxyOptions); } else { LOG.error(U.getReqKey(req), err); }; }; × Search results Close "},"interactive.js.html":{"id":"interactive.js.html","title":"Source: interactive.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: interactive.js &quot;use strict&quot;; /** * Interactive console. * * @function * @name interactive * @arg {Commands} cmd - Commands instance. * @arg {Vorpal} [cli] - Vorpal instance. * @return {Vorpal} - Configured Vorpal instance. */ var vorpal = require(&quot;vorpal&quot;)(); var U = require(&quot;glace-utils&quot;); // HACK to return colors back after vorpal import. require(&quot;colors&quot;); require(&quot;colors/lib/extendStringPrototype&quot;)(); var d = U.switchColor(); var interactive = (cmd, cli) =&gt; { cli = U.defVal(cli, vorpal); cli.command(&quot;url &lt;url&gt;&quot;) .description(d(&quot;Set proxied URL.&quot;)) .action(function (args, cb) { if (!args.url.toString().startsWith(&quot;http&quot;)) { this.log(&quot;Invalid URL&quot;.red); return cb(); }; return cmd .setProxiedUrl(args.url) .then(isOk =&gt; { if (!isOk) return; this.log(`Proxied URL changed to ${args.url}`.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy start http&quot;) .description(d(&quot;Start HTTP proxy.&quot;)) .action(function (args, cb) { return cmd .launchHttpProxy() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;HTTP proxy is launched&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy start global&quot;) .description(d(&quot;Start global proxy.&quot;)) .action(function (args, cb) { return cmd .launchGlobalProxy() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Global proxy is launched&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy stop http&quot;) .description(d(&quot;Stop HTTP proxy.&quot;)) .action(function (args, cb) { return cmd .stopHttpProxy() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;HTTP proxy is stopped&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy stop global&quot;) .description(d(&quot;Stop global proxy.&quot;)) .action(function (args, cb) { return cmd .stopGlobalProxy() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Global proxy is stopped&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy restart http&quot;) .description(d(&quot;Restart HTTP proxy.&quot;)) .action(function (args, cb) { return cmd .restartHttpProxy() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;HTTP proxy is restarted&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy restart global&quot;) .description(d(&quot;Restart global proxy.&quot;)) .action(function (args, cb) { return cmd .restartGlobalProxy() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Global proxy is restarted&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy speed &lt;speed&gt;&quot;) .description(d(&quot;Limit proxy speed, kb/s.&quot;)) .action(function (args, cb) { if (+args.speed &lt; 0) { this.log(&quot;Speed value should be a number&quot;.red); return cb(); }; return cmd .setProxySpeed(+args.speed) .then(isOk =&gt; { if (!isOk) return; this.log( `Proxy speed is limited to ${args.speed} kb/s`.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy requests speed &lt;speed&gt;&quot;) .description(d(&quot;Limit proxy requests speed, kb/s.&quot;)) .action(function (args, cb) { if (+args.speed &lt; 0) { this.log(&quot;Speed value should be a number&quot;.red); return cb(); }; return cmd .setProxySpeed({ req: +args.speed }) .then(isOk =&gt; { if (!isOk) return; this.log( `Proxy requests speed is limited to ${args.speed} kb/s`.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy responses speed &lt;speed&gt;&quot;) .description(d(&quot;Limit proxy responses speed, kb/s.&quot;)) .action(function (args, cb) { if (+args.speed &lt; 0) { this.log(&quot;Speed value should be a number&quot;.red); return cb(); }; return cmd .setProxySpeed({ res: +args.speed }) .then(isOk =&gt; { if (!isOk) return; this.log( `Proxy responses speed is limited to ${args.speed} kb/s`.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;proxy speed reset&quot;) .description(d(&quot;Unlimit proxy speed.&quot;)) .action(function (args, cb) { return cmd .resetProxySpeed() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Proxy speed is unlimited&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;chrome&quot;) .description(d(&quot;Launch google chrome browser.&quot;, &quot;Pristine profile will be used each time.&quot;)) .action(function (args, cb) { return cmd .launchChrome() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Chrome browser is launched&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;chrome close&quot;) .description(d(&quot;Close google chrome browser.&quot;)) .action(function (args, cb) { return cmd .closeChrome() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Chrome browser is closed&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;chrome restart&quot;) .description(d(&quot;Restart google chrome browser.&quot;, &quot;Pristine profile will be used each time.&quot;)) .action(function (args, cb) { return cmd .restartChrome() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Chrome browser is launched&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;cache&quot;) .description(d(&quot;Cache server responses to disk.&quot;, &quot;Cached responses will be replayed by proxy.&quot;)) .action(function (args, cb) { return cmd .enableProxyCache() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Proxy cache is enabled&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;cache disable&quot;) .description(d(&quot;Disable proxy cache.&quot;)) .action(function (args, cb) { return cmd .disableProxyCache() .then(isOk =&gt; { if (!isOk) return; this.log(&quot;Proxy cache is disabled&quot;.green); }) .catch(e =&gt; this.log(e)) .then(cb); }); cli.command(&quot;cache clear&quot;) .description(d(&quot;Remove cached responses from storage.&quot;)) .action(function (args, cb) { return this.prompt({ type: &quot;confirm&quot;, name: &quot;continue&quot;, default: false, message: &quot;Proxy cache will be cleaned. It won't be undo. Continue?&quot;.yellow, }, result =&gt; { if (!result.continue) { this.log(&quot;Cancelled by user&quot;.green); return cb(); }; return cmd.clearProxyCache() .then(() =&gt; this.log(&quot;Proxy cache is cleaned&quot;.green)) .catch(e =&gt; this.log(e)) .then(cb); }); }); cli.delimiter(&quot;&gt;&quot;.red.bold).show(); var finalize = () =&gt; { if (cmd._isChromeLaunched()) cmd.closeChrome(); }; cli.on(&quot;client_prompt_submit&quot;, name =&gt; { if (name === &quot;exit&quot;) finalize(); }); return cli; }; module.exports = interactive; × Search results Close "},"pluginHelp.js.html":{"id":"pluginHelp.js.html","title":"Source: pluginHelp.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: pluginHelp.js &quot;use strict&quot;; /** * `Proxy` plugin help. * * @function */ module.exports = (args, d) =&gt; { return args .options({ &quot;http-proxy&quot;: { describe: d(&quot;Use http proxy.&quot;), type: &quot;boolean&quot;, group: &quot;Proxy:&quot;, }, &quot;http-proxy-port [number]&quot;: { describe: d(&quot;Port for http proxy. Default is random.&quot;, &quot;Incompatible with '--slaves' option.&quot;), type: &quot;number&quot;, group: &quot;Proxy:&quot;, }, &quot;global-proxy&quot;: { describe: d(&quot;Use transparent global proxy.&quot;), type: &quot;boolean&quot;, group: &quot;Proxy:&quot;, }, &quot;global-proxy-port [number]&quot;: { describe: d(&quot;Port for transparent global proxy.&quot;, &quot;Default is random. Incompatible with '--slaves' option.&quot;), type: &quot;number&quot;, group: &quot;Proxy:&quot;, }, &quot;cache&quot;: { describe: d(&quot;Enable middleware to cache proxy responses to disk.&quot;), type: &quot;boolean&quot;, group: &quot;Proxy:&quot;, }, &quot;existing-cache&quot;: { describe: d(&quot;Use existing cache if it exists.&quot;), type: &quot;boolean&quot;, group: &quot;Proxy:&quot;, }, &quot;cache-folder [folder]&quot;: { describe: d(&quot;Folder to put cached server responses.&quot;, &quot;Default is 'cwd/.proxy-cache'.&quot;), type: &quot;string&quot;, group: &quot;Proxy:&quot;, }, &quot;speed &lt;value&gt;&quot;: { describe: d(&quot;Proxy speed, kb/s.&quot;), type: &quot;number&quot;, group: &quot;Proxy:&quot;, }, &quot;install-certificate&quot;: { describe: d(&quot;Install global proxy certificate as trusted.&quot;, &quot;Requires administrator permissions.&quot;), type: &quot;boolean&quot;, group: &quot;Proxy:&quot;, }, &quot;ssl-ca-dir [folder]&quot;: { describe: d(&quot;Folder to put generated self-signed ssl certificates.&quot;), type: &quot;string&quot;, group: &quot;Proxy:&quot;, }, &quot;reconnect [value]&quot;: { describe: d(&quot;Number of proxy reconnects on request error.&quot;, &quot;Default is 2.&quot;), type: &quot;number&quot;, group: &quot;Proxy:&quot;, }, }); }; × Search results Close "},"cli.js.html":{"id":"cli.js.html","title":"Source: cli.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: cli.js &quot;use strict&quot;; /** * `GlaceJS` proxy runner. * * @module */ require(&quot;./help&quot;); var U = require(&quot;glace-utils&quot;); var Commands = require(&quot;./commands&quot;); var CONF = require(&quot;./config&quot;); var interactive = require(&quot;./interactive&quot;); /** * Proxy runner. * * @function * @arg {Commands} cmd - Commands. * @return {Promise&lt;void&gt;} */ module.exports.run = cmd =&gt; { cmd = U.defVal(cmd, new Commands(CONF, { logger: console.log, colored: true })); return Promise .resolve() .then(() =&gt; { if (CONF.proxy.global) return cmd.launchGlobalProxy(); }) .then(() =&gt; { if (CONF.proxy.http) return cmd.launchHttpProxy(); }) .then(() =&gt; { if (CONF.chrome.launch) return cmd.launchChrome(); }) .then(() =&gt; interactive(cmd)) .catch(U.exit(&quot;Promise error&quot;)); }; process.on(&quot;uncaughtException&quot;, U.exit(&quot;Uncaught Exception&quot;)); process.on(&quot;unhandledRejection&quot;, U.exit(&quot;Unhandled Rejection&quot;)); × Search results Close "},"config.js.html":{"id":"config.js.html","title":"Source: config.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: config.js &quot;use strict&quot;; /** * Configures `GlaceJS` proxy before run. * * @module */ var path = require(&quot;path&quot;); var _ = require(&quot;lodash&quot;); const expect = require(&quot;chai&quot;).expect; var U = require(&quot;glace-utils&quot;); /* Set up default config */ /** * Contains `GlaceJS` proxy configuration. * * @namespace GlaceConfig * @prop {?string} [url=null] - Proxied URL. * @prop {object} cache - Cache config. * @prop {number} [cache.ttl] - Time to life cache. Default is maximum. * @prop {number} [cache.size] - Maximum cached file size. Default is 10 GB. * @prop {boolean} [cache.use=false] - Use cache. * @prop {boolean} [cache.existing=false] - Use existing cache if exists. * @prop {boolean} [cache.folder=cwd/.proxy-cache] - Cache folder. * @prop {object} chrome - Chrome config. * @prop {boolean} [chrome.launch=false] - Launch chrome browser. * @prop {boolean} [chrome.incognito=false] - Use incognito mode in chrome. * @prop {object} log - Log config. * @prop {string} [log.level=debug] - Log level. * @prop {string} [log.path=cwd/glace-proxy.log] - Log file path. * @prop {boolean} [log.stdout=false] - Print log messages to terminal. * @prop {object} proxy - Proxy config. * @prop {number} [proxy.timeout=60000] - Proxy time to wait for remote response, ms. * @prop {number} [proxy.http=false] - Launch http proxy. * @prop {number} [proxy.port=0] - Proxy port. By default will be assigned by OS. * @prop {boolean} [proxy.global=false] - Launch global proxy. * @prop {number} [proxy.globalPort=8888] - Global proxy port. * @prop {boolean} [proxy.installCertificates] - Install global proxy certificates * as trusted. Windows only. Admin privileges are required. * @prop {number} [proxy.reconnect=2] - Number of reconnect attemptions if * remote side breaks connection. */ var config = _.merge(U.config, { cache: { ttl: Number.MAX_SAFE_INTEGER, size: 10 * 1024 * 1024 * 1024 }, chrome: { }, log: { level: &quot;debug&quot;, }, proxy: { timeout: 60000, }, }); var args = config.args; config.report = U.defVal(config.report, {}); config.report.dir = U.defVal(config.report.dir, U.cwd); config.cluster = U.defVal(config.cluster, {}); /* Use CLI arguments */ config.web = U.defVal(config.web, {}); config.web.url = args.webUrl; // proxied URL config.proxy.http = !!args.httpProxy; // default is `false` config.proxy.port = args.httpProxyPort || 0; // default is random if (config.cluster.slavesNum) { expect(config.proxy.port, &quot;`--http-proxy-port` is incompatible with `--slaves`&quot;).to.be.equal(0); } config.proxy.global = !!args.globalProxy; //default `false` config.proxy.globalPort = args.globalProxyPort || 0; // default is random if (config.cluster.slavesNum) { expect(config.proxy.globalPort, &quot;`--global-proxy-port` is incompatible with `--slaves`&quot;).to.be.equal(0); } config.proxy.speed = args.speed; // default unlimited config.proxy.installCertificate = !!args.installCertificate; //default `false` config.proxy.sslCaDir = path.resolve(config.report.dir, U.defVal(args.sslCaDir, &quot;.certificates&quot;)); config.proxy.reconnect = args.reconnect || 2; // TODO maybe to make as CLI option config.cache.use = !!args.cache || !!args.existingCache; // default `false` config.cache.existing = !!args.existingCache; // default `false` config.cache.folder = path.resolve(config.report.dir, U.defVal(args.cacheFolder, &quot;.proxy-cache&quot;)); config.chrome.launch = !!args.chrome; // default `false` config.chrome.incognito = !!args.chromeIncognito; // default `false` module.exports = config; × Search results Close "},"help.js.html":{"id":"help.js.html","title":"Source: help.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: help.js &quot;use strict&quot;; /** * Help description. * * @module */ require(&quot;colors&quot;); var U = require(&quot;glace-utils&quot;); var d = U.switchColor(); U.help(d) .usage(&quot;\\nglace-proxy [options]&quot;.white.bold) .options({ /* proxy */ &quot;web-url &lt;URL&gt;&quot;: { describe: d(&quot;Proxied URL for HTTP proxy.&quot;, &quot;Required if HTTP proxy is used.&quot;), type: &quot;string&quot;, group: &quot;Proxy:&quot;, }, &quot;http-proxy&quot;: { describe: d(&quot;Activate HTTP proxy.&quot;), type: &quot;boolean&quot;, group: &quot;Proxy:&quot;, }, &quot;http-proxy-port [port-number]&quot;: { describe: d(&quot;Port for HTTP proxy. Default is random.&quot;), type: &quot;number&quot;, group: &quot;Proxy:&quot;, }, &quot;global-proxy&quot;: { describe: d(&quot;Activate transparent global proxy.&quot;), type: &quot;boolean&quot;, group: &quot;Proxy:&quot;, }, &quot;global-proxy-port [port-number]&quot;: { describe: d(&quot;Port for transparent global proxy. Default is random.&quot;), type: &quot;number&quot;, group: &quot;Proxy:&quot;, }, &quot;install-certificate&quot;: { describe: d(&quot;Install global proxy certificate as trusted.&quot;, &quot;Requires administrator permissions.&quot;, &quot;Windows only.&quot;), type: &quot;boolean&quot;, group: &quot;Proxy:&quot;, }, &quot;speed &lt;value&gt;&quot;: { describe: d(&quot;Responses speed from proxy to client (browser), kb/s.&quot;, &quot;Default is unlimited.&quot;), type: &quot;number&quot;, group: &quot;Proxy:&quot;, }, /* cache */ &quot;cache&quot;: { describe: d(&quot;Cache server responses to disk.&quot;), type: &quot;boolean&quot;, group: &quot;Cache:&quot;, }, &quot;existing-cache&quot;: { describe: d(&quot;Cache server responses to disk.&quot;, &quot;Connect to existing cache if it exists.&quot;), type: &quot;boolean&quot;, group: &quot;Cache:&quot;, }, &quot;cache-folder [folder-path]&quot;: { describe: d(&quot;Folder to cache server responses.&quot;, &quot;Default is 'cwd/.proxy-cache'&quot;), type: &quot;string&quot;, group: &quot;Cache:&quot;, }, /* chrome */ &quot;chrome&quot;: { describe: d(&quot;Launch google chrome and open proxied URL there.&quot;, &quot;Pristine profile will be used.&quot;), type: &quot;boolean&quot;, group: &quot;Chrome:&quot;, }, &quot;chrome-incognito&quot;: { describe: d(&quot;Launch google chrome in incognito mode.&quot;), type: &quot;boolean&quot;, group: &quot;Chrome:&quot;, }, }) .argv; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: index.js &quot;use strict&quot;; /** * `GlaceJS` proxy. * * @module */ var Commands, config, GlobalProxy, HttpProxy, interactive, middleware, mw, pluginHelp, Steps; Object.defineProperties(exports, { /** * @type {Commands} */ Commands: { get: function () { Commands = Commands || require(&quot;./commands&quot;); return Commands; }, }, /** * @type {GlaceProxyConfig} */ config: { get: function () { config = config || require(&quot;./config&quot;); return config; }, }, /** * @type {GlobalProxy} */ GlobalProxy: { get: function () { GlobalProxy = GlobalProxy || require(&quot;./globalProxy&quot;); return GlobalProxy; }, }, /** * @type {HttpProxy} */ HttpProxy: { get: function () { HttpProxy = HttpProxy || require(&quot;./httpProxy&quot;); return HttpProxy; }, }, /** * @type {interactive} */ interactive: { get: function () { interactive = interactive || require(&quot;./interactive&quot;); return interactive; }, }, middleware: { get: function () { middleware = middleware || require(&quot;./middleware&quot;); return middleware; }, }, mw: { get: function () { mw = mw || { cache: require(&quot;./middleware/cache&quot;), info: require(&quot;./middleware/info&quot;), reqBody: require(&quot;./middleware/reqBody&quot;), resHead: require(&quot;./middleware/resHead&quot;), speed: require(&quot;./middleware/speed&quot;), }; return mw; }, }, /** * @type {pluginHelp} */ pluginHelp: { get: function () { pluginHelp = pluginHelp || require(&quot;./pluginHelp&quot;); return pluginHelp; }, }, /** * @type {ProxySteps} */ Steps: { get: function () { Steps = Steps || require(&quot;./steps&quot;); return Steps; }, }, }); × Search results Close "},"middleware_cache.js.html":{"id":"middleware_cache.js.html","title":"Source: middleware/cache.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: middleware/cache.js &quot;use strict&quot;; /** * Middleware to cache responses. * * @module */ var fs = require(&quot;fs&quot;); var cacheManager = require(&quot;cache-manager&quot;); var fse = require(&quot;fs-extra&quot;); var fsStore = require(&quot;cache-manager-fs&quot;); var U = require(&quot;glace-utils&quot;); var CONF = require(&quot;../config&quot;); var LOG = U.logger; if (!CONF.cache.existing &amp;&amp; fs.existsSync(CONF.cache.folder)) { fse.removeSync(CONF.cache.folder); }; fse.mkdirsSync(CONF.cache.folder); var diskCache; var inited; var init = opts =&gt; { opts = U.defVal(opts, {}); opts.force = U.defVal(opts.force, false); if (!inited || opts.force) { inited = new Promise(resolve =&gt; { var fillcb = null; if (CONF.cache.existing) fillcb = resolve; diskCache = cacheManager.caching({ store: fsStore, options: { ttl: CONF.cache.ttl, maxsize: CONF.cache.size, path: CONF.cache.folder, preventfill: !CONF.cache.existing, fillcallback: fillcb } }); if (!CONF.cache.existing) resolve(); }); }; return inited; }; init(); /** * Middleware to cache server responses and reply them. * * @function * @this BaseProxy * @return {boolean} - `true` if response was retrieved from cache, `false` * otherwise. */ var cache = module.exports = async function () { if (!this.useCache) return false; if (!diskCache) return false; for (var skipped of cache.skipped.req) { if (skipped(this.req)) return false; }; var req = this.req; var res = this.res; var result; if (await fromCache(req, res)) { result = true; } else { toCache(req, res); result = false; }; return result; }; /** * @prop {object} skipped - Filters to skip caching. * @prop {function[]} [skipped.req=[]] - List of filters to skip by request. * @prop {function[]} [skipped.res=[]] - List of filters to skip by response. */ cache.skipped = { req: [], res: [] }; /** * Initializes cache. Does nothing if it is initialized already and no force option. * * @function * @arg {object} [opts] - Initialization options. * @arg {boolean} [opts.force=false] - Force reinitialize cache. * @return {Promise} */ cache.init = init; /** * Patches http response to send response from cache, if it is there. * * @function * @arg {object} req - http(s) request * @arg {object} res - http(s) response * @return {Promise.&lt;boolean&gt;} - `true` if response is in cache and * was patched, otherwise `false` */ var fromCache = (req, res) =&gt; { return new Promise((resolve, reject) =&gt; { diskCache.get(U.getReqKey(req), (err, result) =&gt; { if (err) return reject(err); resolve(result); }); }).then(cached =&gt; { if (!cached) return false; LOG.silly(&quot;[cache] &lt;&lt;&lt;&lt;&quot;, U.getReqKey(req)); var response = JSON.parse(cached); res.writeHead(response.code, response.headers); res.end(Buffer.from(response.data)); return true; }); }; /** * Patches http response to put response to cache. * * @function * @arg {object} req - http(s) request * @arg {object} res - http(s) response */ var toCache = (req, res) =&gt; { var resWrite = res.write; var resEnd = res.end; var chunks = []; res.write = function (chunk) { if (chunk instanceof Buffer) chunks.push(chunk); resWrite.apply(this, arguments); }; res.end = function (chunk) { if (chunk instanceof Buffer) chunks.push(chunk); var data = Buffer.concat(chunks).toJSON().data; if (res.statusCode !== 200 || data.length === 0) { return resEnd.apply(this, arguments); }; for (var skipped of cache.skipped.res) { if (skipped(res)) { return resEnd.apply(this, arguments); }; }; var resData = JSON.stringify({ data: data, code: res.statusCode, headers: res.headers }); LOG.silly(&quot;[cache] &gt;&gt;&gt;&gt;&quot;, U.getReqKey(req)); diskCache.set(U.getReqKey(req), resData); resEnd.apply(this, arguments); }; }; × Search results Close "},"middleware_index.js.html":{"id":"middleware_index.js.html","title":"Source: middleware/index.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: middleware/index.js &quot;use strict&quot;; /** * Proxy middlewares. * * @module */ module.exports = [ require(&quot;./reqBody&quot;), require(&quot;./resHead&quot;), require(&quot;./speed&quot;), require(&quot;./info&quot;), require(&quot;./cache&quot;), ]; × Search results Close "},"middleware_info.js.html":{"id":"middleware_info.js.html","title":"Source: middleware/info.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: middleware/info.js &quot;use strict&quot;; /** * Contains proxy middlewares * * @module */ var _ = require(&quot;lodash&quot;); module.exports = function () { if (!this.responsesData) return false; var res = this.res; var req = this.req; var data = { name: req.headers.host + req.url, method: req.method, reqHeaders: req.headers, resHeaders: {}, statusCode: null, statusMessage: null, size: 0, chunkSizes: [] }; this.responsesData.push(data); var resWrite = res.write; var resEnd = res.end; var addData = chunk =&gt; { if (!chunk) return; data.chunkSizes.push(chunk.length); data.size += chunk.length; }; res.write = function (chunk) { addData(chunk); resWrite.apply(this, arguments); }; res.end = function (chunk) { addData(chunk); data.resHeaders = _.cloneDeep(res.headers); data.statusCode = res.statusCode; data.statusMessage = data.statusMessage; resEnd.apply(this, arguments); }; return false; }; × Search results Close "},"middleware_reqBody.js.html":{"id":"middleware_reqBody.js.html","title":"Source: middleware/reqBody.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: middleware/reqBody.js &quot;use strict&quot;; /** * Middleware to store request body. * * @module */ module.exports = function () { var chunks = []; var req = this.req; if (req.body) return; var emit = req.emit; req.emit = function (ev, chunk) { if (ev === &quot;data&quot;) { if (chunk instanceof Buffer) chunks.push(chunk); } else if (ev === &quot;end&quot;) { if (chunk instanceof Buffer) chunks.push(chunk); req.body = Buffer.concat(chunks); }; emit.apply(this, arguments); }; }; × Search results Close "},"middleware_resHead.js.html":{"id":"middleware_resHead.js.html","title":"Source: middleware/resHead.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: middleware/resHead.js &quot;use strict&quot;; /** * Middleware to cache responses. * * @module */ var _ = require(&quot;lodash&quot;); module.exports = function () { var res = this.res; var resHead = res.writeHead; var resHeader = res.setHeader; res.headers = res.headers || {}; res.writeHead = function (statusCode, statusMsg, headers) { if (_.isPlainObject(statusMsg) &amp;&amp; !headers) { headers = statusMsg; statusMsg = undefined; }; if (statusCode) { res.statusCode = res.statusCode || statusCode; }; if (statusMsg) { res.statusMessage = res.statusMessage || statusMsg; }; if (_.isPlainObject(headers)) { _.assign(res.headers, headers); }; return resHead.apply(this, arguments); }; res.setHeader = function(name, value) { res.headers[name] = value; return resHeader.apply(this, arguments); }; }; × Search results Close "},"middleware_speed.js.html":{"id":"middleware_speed.js.html","title":"Source: middleware/speed.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: middleware/speed.js &quot;use strict&quot;; /** * Middleware to manage responses speed. * * @module */ var U = require(&quot;glace-utils&quot;); var MAX_PACKAGE_SIZE = 8192; // empirical value var self = module.exports = function () { self.__changeReqSpeed(this); self.__changeResSpeed(this); return false; }; /** * Helper to change requests speed. * * @ignore * @function * @arg {BaseProxy} ctx - Proxy instance. */ self.__changeReqSpeed = ctx =&gt; { if (ctx.reqSpeed == null) return; var req = ctx.req; var timer = 1000; var size = Math.ceil(ctx.reqSpeed * 128); var prms = Promise.resolve(); [size, timer] = self.__balance(size, timer); var promisify = self.__promisify(size, timer); var emit = req.emit; req.emit = function (ev, chunk) { if (![&quot;data&quot;, &quot;end&quot;].includes(ev)) { return emit.apply(this, arguments); }; if (size === 0) return; // reject requests if speed is zero prms = promisify(prms, chunk, chk =&gt; { return emit.call(this, &quot;data&quot;, chk); }); if (ev === &quot;end&quot;) { prms = prms.then(() =&gt; { return emit.call(this, &quot;end&quot;); }); }; return prms; }; }; /** * Helper to change responses speed. * * @ignore * @function * @arg {BaseProxy} ctx - Proxy instance. */ self.__changeResSpeed = ctx =&gt; { if (ctx.resSpeed == null) return; var res = ctx.res; var timer = 1000; var size = Math.ceil(ctx.resSpeed * 128); var prms = Promise.resolve(); [size, timer] = self.__balance(size, timer); var promisify = self.__promisify(size, timer); var write = res.write; res.write = function () { if (size === 0) return; // reject responses if speed is zero var args = Array.from(arguments); prms = promisify(prms, args[0], chk =&gt; { args[0] = chk; return write.apply(this, args); }); return prms; }; var end = res.end; res.end = function () { if (size === 0) return; // reject responses if speed is zero var args = Array.from(arguments); prms = promisify(prms, args[0], chk =&gt; { args[0] = chk; return write.apply(this, args); }); return prms.then(() =&gt; { args[0] = null; return end.apply(res, args); }); }; }; /** * Helper to balance data size and throttle time. * * @ignore * @function * @arg {number} size - Data size, bytes. * @arg {number} timer - Throttle time, ms. * @return {number[]} Balanced size and timer. */ self.__balance = (size, timer) =&gt; { while (size &gt; MAX_PACKAGE_SIZE) { size = Math.ceil(size / 2); timer = Math.ceil(timer / 2); }; return [size, timer]; }; /** * Helper to promisify requests and responses with size and time. * * @ignore * @function * @arg {number} size - Data size, bytes. * @arg {number} timer - Throttle time, ms. * @return {function} Function to promisify request or response. */ self.__promisify = (size, timer) =&gt; (prms, chunk, cb) =&gt; { if (!chunk) return prms; for (var i = 0; i &lt; chunk.length; i += size) { prms = prms .then(() =&gt; U.sleep(timer)) .then((idx =&gt; () =&gt; cb(chunk.slice(idx, idx + size)))(i)); }; return prms; }; × Search results Close "},"steps.js.html":{"id":"steps.js.html","title":"Source: steps.js","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Source: steps.js &quot;use strict&quot;; /** * Steps to manage proxy. * * These methods are mixed with glacejs [Steps](https://glacejs.github.io/glace-core/Steps.html) * class and available via its instance [SS](https://glacejs.github.io/glace-core/global.html#SS) * in tests. * * @mixin ProxySteps * @prop {string} webUrl - Web application URL. * @prop {GlobalProxy} globalProxy - Global proxy instance. * @prop {HttpProxy} httpProxy - HTTP proxy instance. */ var url = require(&quot;url&quot;); var util = require(&quot;util&quot;); var _ = require(&quot;lodash&quot;); var expect = require(&quot;chai&quot;).expect; var U = require(&quot;glace-utils&quot;); require(&quot;./fixtures&quot;); var GlobalProxy = require(&quot;./globalProxy&quot;); var HttpProxy = require(&quot;./httpProxy&quot;); var LOG = U.logger; var ProxySteps = { __GlobalProxy: GlobalProxy, __HttpProxy: HttpProxy, registerProxy: function (opts) { /** * Helper to register proxy classes. * * @memberOf ProxySteps * @method registerProxy * @instance * @arg {object} [opts] - Options. * @arg {object} [opts.GlobalProxy] - Global proxy class. * @arg {object} [opts.HttpProxy] - HTTP proxy class. * @example * * SS.registerProxy({ GlobalProxy: MyGlobalProxy, HttpProxy: MyHttpProxy }); */ opts = U.defVal(opts, {}); this.__GlobalProxy = U.defVal(opts.GlobalProxy, this.__GlobalProxy); this.__HttpProxy = U.defVal(opts.HttpProxy, this.__HttpProxy); }, startHttpProxy: async function (opts) { /** * Step to start HTTP proxy. Step recall will be skipped if proxy wasn't * stopped before. * * @async * @memberOf ProxySteps * @method startHttpProxy * @instance * @arg {object} [opts] - Step options. * @arg {string} [opts.webUrl] - Web application url which will * be proxied. Default value will be requested from `config.web.url` * if it is specified. * @arg {boolean} [opts.useCache] - Flag to use proxy cache for * responses. Default value will be requested from `config.useCache` * if it is specified. * @arg {number} [opts.timeout] - Proxy timeout to break connection. * Default value will be requested from `config.timeout.proxy`. * @arg {number} [opts.reconnect] - Number of proxy reconnects on failure. * @arg {number} [opts.port] - Proxy port. Default value will be * requested from `config.proxyPort`. * @arg {boolean} [opts.check=true] - Flag to check that proxy was launched. * @return {Promise&lt;string&gt;} Proxied URL. * @return {Promise&lt;boolean&gt;} `false` if step was skipped * @throws {AssertionError} If proxy was not launched. * @example * * var proxiedUrl = await SS.startHttpProxy(); * var proxiedUrl = await SS.startHttpProxy({ webUrl: &quot;http://example.com&quot;, }); * var proxiedUrl = await SS.startHttpProxy({ webUrl: &quot;http://example.com&quot;, port: 8080 }); */ if (this._isProxyStarted) { LOG.warn(&quot;Step to start proxy was passed already&quot;); return false; }; opts = U.defVal(opts, {}); var webUrl = U.defVal(opts.webUrl, CONF.web &amp;&amp; CONF.web.url); var useCache = U.defVal(opts.useCache, CONF.cache.use); var timeout = U.defVal(opts.timeout, CONF.proxy.timeout); var reconnect = U.defVal(opts.reconnect, CONF.proxy.reconnect); var port = U.defVal(opts.port, CONF.proxy.port); var check = U.defVal(opts.check, true); allure.step(&quot;Start http proxy&quot;); expect(webUrl, &quot;Web URL for http proxy isn't specified&quot;).to.exist; LOG.info(&quot;Starting http proxy...&quot;); this.httpProxy = this.httpProxy || new this.__HttpProxy({ url: webUrl, useCache: useCache, timeout: timeout, reconnect: reconnect, port: port }); await this.httpProxy.start(); if (check) { expect(this.httpProxy.isRunning, &quot;HTTP proxy was not launched&quot;).be.true; }; this._isProxyStarted = true; this.webUrl = _.trim( this.httpProxy.url + url.parse(CONF.web.url).pathname, &quot;/&quot;); LOG.info(&quot;Http proxy is started&quot;); allure.pass(); return this.webUrl; }, getProxyUrl: function (opts) { /** * Step to get proxy URL. * * @memberOf ProxySteps * @method getProxyUrl * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that proxy URL is * defined. * @return {string} Proxy URL. * @throws {AssertionError} If proxy URL isn't defined. * @example * * var proxiedUrl = SS.getProxiedUrl(); */ opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); allure.step(&quot;Get http proxy url&quot;); LOG.info(&quot;Getting http proxy url...&quot;); if (check) { expect(this.httpProxy.url, &quot;HTTP proxy was not launched&quot;).to.exist; }; LOG.info(&quot;Http proxy url is got&quot;); allure.pass(); return this.httpProxy.url; }, stopHttpProxy: async function (opts) { /** * Step to stop HTTP proxy. Step call will be skipped if proxy wasn't * launched before. * * @async * @memberOf ProxySteps * @method stopHttpProxy * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that proxy was * stopped. * @return {Promise&lt;boolean&gt;} `true` if step was passed, `false` if was * skipped. * @throws {AssertionError} If proxy wasn't stopped. * @example * * await SS.stopHttpProxy(); */ if (!this._isProxyStarted) { LOG.warn(&quot;Step to start HTTP proxy wasn't passed yet&quot;); return false; }; opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); allure.step(&quot;Stop http proxy&quot;); LOG.info(&quot;Stopping http proxy...&quot;); await this.httpProxy.stop(); if (check) { expect(this.httpProxy.isRunning, &quot;HTTP proxy wasn't stopped&quot;).be.false; }; this.webUrl = CONF.web.url; this._isProxyStarted = false; LOG.info(&quot;Http proxy is stopped&quot;); allure.pass(); return true; }, startGlobalProxy: async function (opts) { /** * Step to start global proxy. Step recall will be skipped if global * proxy wasn't stopped before. * * @async * @memberOf ProxySteps * @method startGlobalProxy * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.useCache] - Flag to use proxy cache for * responses. Default value will be requested from `config.useCache` * if it is specified. * @arg {number} [opts.timeout] - Proxy timeout to break connection. * Default value will be requested from `config.timeout.proxy`. * @arg {number} [opts.reconnect] - Number of proxy reconnects on failure. * @arg {number} [opts.port] - Proxy port. Default value will be * requested from `config.globalProxyPort`. * @arg {boolean} [opts.check=true] - Flag to check that proxy was launched. * @return {Promise&lt;boolean&gt;} `true` if step was passed, `false` if was * skipped. * @throws {AssertionError} If global proxy was not launched. * @example * * await SS.startGlobalProxy(); * await SS.startGlobalProxy({ timeout: 30000 }); */ if (this._isGlobalProxyStarted) { LOG.warn(&quot;Step to start global proxy was passed already&quot;); return false; }; opts = U.defVal(opts, {}); var useCache = U.defVal(opts.useCache, CONF.cache.use); var timeout = U.defVal(opts.timeout, CONF.proxy.timeout); var reconnect = U.defVal(opts.reconnect, CONF.proxy.reconnect); var port = U.defVal(opts.port, CONF.proxy.globalPort); const sslCaDir = U.defVal(opts.sslCaDir, CONF.proxy.sslCaDir); var check = U.defVal(opts.check, true); allure.step(&quot;Start global proxy&quot;); LOG.info(&quot;Starting global proxy...&quot;); this.globalProxy = this.globalProxy || new this.__GlobalProxy({ useCache: useCache, timeout: timeout, reconnect: reconnect, port: port, sslCaDir: sslCaDir, installCertificate: CONF.proxy.installCertificate }); await this.globalProxy.start(); if (check) { expect(this.globalProxy.isRunning, &quot;Global proxy was not launched&quot;) .to.be.true; }; this._isGlobalProxyStarted = true; LOG.info(&quot;Global proxy is started&quot;); allure.pass(); return true; }, stopGlobalProxy: async function (opts) { /** * Step to stop global proxy. Step call will be skipped if global proxy * wasn't launched before. * * @async * @memberOf ProxySteps * @method stopGlobalProxy * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that global * proxy was stopped. * @return {Promise&lt;boolean&gt;} `true` if step was passed, `false` if was * skipped. * @throws {AssertionError} If global proxy wasn't stopped. * @example * * await SS.stopGlobalProxy(); */ if (!this._isGlobalProxyStarted) { LOG.warn(&quot;Step to start global proxy wasn't passed yet&quot;); return false; }; opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); allure.step(&quot;Stop global proxy&quot;); LOG.info(&quot;Stopping global proxy...&quot;); await this.globalProxy.stop(); if (check) { expect(this.globalProxy.isRunning, &quot;Global proxy wasn't stopped&quot;).be.false; }; this._isGlobalProxyStarted = false; LOG.info(&quot;Global proxy is stopped&quot;); allure.pass(); return true; }, limitProxySpeed: function (speed, opts) { /** * Step to limit proxy speed. * * @memberOf ProxySteps * @method limitProxySpeed * @instance * @arg {number|object} speed - Proxy limited speed, kb/s. * @arg {?number} [speed.req] - Requests speed, kb/s. * @arg {?number} [speed.res] - Responses speed, kb/s. * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that proxy speed * is limited. * @return {boolean} `true` if step was passed. * @throws {AssertionError} If proxy speed is not limited. * @example * * SS.limitProxySpeed(512); * SS.limitProxySpeed({ res: 512 }); */ this._checkProxy(); opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); allure.step(util.format(&quot;Limit proxy speed to&quot;, speed, &quot;kb/s&quot;)); LOG.info(&quot;Limiting proxy speed to&quot;, speed, &quot;kb/s...&quot;); if (this.httpProxy) { this.httpProxy.setSpeed(speed); }; if (this.globalProxy) { this.globalProxy.setSpeed(speed); }; if (check) { if (speed.req === undefined &amp;&amp; speed.res === undefined) { speed = { req: speed, res: speed }; }; if (this.httpProxy) { if (speed.req !== undefined) { expect(this.httpProxy.reqSpeed, &quot;HTTP proxy requests speed is not limited&quot;) .be.equal(speed.req); }; if (speed.res !== undefined) { expect(this.httpProxy.resSpeed, &quot;HTTP proxy responses speed is not limited&quot;) .be.equal(speed.res); }; }; if (this.globalProxy) { if (speed.req !== undefined) { expect(this.globalProxy.reqSpeed, &quot;Global proxy requests speed is not limited&quot;) .be.equal(speed.req); }; if (speed.res !== undefined) { expect(this.globalProxy.resSpeed, &quot;Global proxy responses speed is not limited&quot;) .be.equal(speed.res); }; }; }; LOG.info(&quot;Proxy speed is limited&quot;); allure.pass(); return true; }, unlimitProxySpeed: function (opts) { /** * Step to unlimit proxy speed. * * @memberOf ProxySteps * @method unlimitProxySpeed * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that proxy speed * is unlimited. * @return {boolean} `true` if step is passed. * @throws {AssertionError} If proxy speed is still limited. * @example * * SS.unlimitProxySpeed(); */ this._checkProxy(); opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); allure.step(&quot;Unlimit proxy speed&quot;); LOG.info(&quot;Unlimiting proxy speed...&quot;); if (this.httpProxy) { this.httpProxy.resetSpeed(); }; if (this.globalProxy) { this.globalProxy.resetSpeed(); }; if (check) { if (this.httpProxy) { expect(this.httpProxy.reqSpeed, &quot;HTTP proxy requests speed still has limited value&quot;) .be.null; expect(this.httpProxy.resSpeed, &quot;HTTP proxy responses speed still has limited value&quot;) .be.null; }; if (this.globalProxy) { expect(this.globalProxy.reqSpeed, &quot;Global proxy requests speed still has limited value&quot;) .be.null; expect(this.globalProxy.resSpeed, &quot;Global proxy responses speed still has limited value&quot;) .be.null; }; }; LOG.info(&quot;Proxy speed is unlimited&quot;); allure.pass(); return true; }, measureResponses: function (opts) { /** * Step to start responses measurement. * * @memberOf ProxySteps * @method measureResponses * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that responses * measurement is launched. * @return {boolean} `true` if step is passed. * @throws {AssertionError} If responses measurement is not launched. * @example * * SS.measureResponses(); */ this._checkProxy(); opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); allure.step(&quot;Start to measure proxy responses&quot;); LOG.info(&quot;Starting to measure proxy responses...&quot;); if (this.httpProxy) { this.httpProxy.measureResponses(); }; if (this.globalProxy) { this.globalProxy.measureResponses(); }; if (check) { if (this.httpProxy) { expect(this.httpProxy.getResponsesData(), &quot;HTTP proxy responses measurement is not launched&quot;) .to.exist; }; if (this.globalProxy) { expect(this.globalProxy.getResponsesData(), &quot;Global proxy responses measurement is not launched&quot;) .to.exist; }; }; LOG.info(&quot;Proxy responses are measuring&quot;); allure.pass(); return true; }, getResponsesData: function (opts) { /** * Step to get measured responses data. * * @memberOf ProxySteps * @method getResponsesData * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that responses * data are present. * @throws {AssertionError} If responses data are absent. * @return {object[]} List of captured response data. * @example * * var responses = SS.getResponsesData(); */ this._checkProxy(); opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); var data = []; allure.step(&quot;Get responses data&quot;); LOG.info(&quot;Getting responses data...&quot;); if (this.httpProxy &amp;&amp; this.httpProxy.getResponsesData()) { data = data.concat(this.httpProxy.getResponsesData()); }; if (this.globalProxy &amp;&amp; this.globalProxy.getResponsesData()) { data = data.concat(this.globalProxy.getResponsesData()); }; if (check) { expect(_.isEmpty(data), &quot;Responses data are absent&quot;).be.false; }; LOG.info(&quot;Responses data is got&quot;); allure.pass(); return data; }, unmeasureResponses: function (opts) { /** * Step to stop responses measurement. * * @memberOf ProxySteps * @method unmeasureResponses * @instance * @arg {object} [opts] - Step options. * @arg {boolean} [opts.check=true] - Flag to check that responses * measurement is stopped. * @return {boolean} `true` if step is passed. * @throws {AssertionError} If responses measurement is still running. * @example * * SS.unmeasureResponses(); */ this._checkProxy(); opts = U.defVal(opts, {}); var check = U.defVal(opts.check, true); allure.step(&quot;Stop to measure proxy responses&quot;); LOG.info(&quot;Stopping to measure proxy responses...&quot;); if (this.httpProxy) { this.httpProxy.unmeasureResponses(); }; if (this.globalProxy) { this.globalProxy.unmeasureResponses(); }; if (check) { if (this.httpProxy) { expect(this.httpProxy.getResponsesData(), &quot;HTTP proxy responses measurement is still running&quot;) .to.be.null; }; if (this.globalProxy) { expect(this.globalProxy.getResponsesData(), &quot;Global proxy responses measurement is still running&quot;) .to.be.null; }; }; LOG.info(&quot;Proxy responses are not measured&quot;); allure.pass(); return true; }, enableCache: function () { /** * Step to enable cache. * * @memberOf ProxySteps * @method enableCache * @instance * @return {boolean} `true` if step is passed. * @example * * SS.enableCache(); */ allure.step(&quot;Enable proxy cache&quot;); this._checkProxy(); LOG.info(&quot;Enabling proxy cache...&quot;); if (this.httpProxy) this.httpProxy.useCache = true; if (this.globalProxy) this.globalProxy.useCache = true; LOG.info(&quot;Proxy cache is enabled&quot;); allure.pass(); return true; }, disableCache: function () { /** * Step to disable cache. * * @memberOf ProxySteps * @method disableCache * @instance * @return {boolean} `true` if step is passed. * @example * * SS.disableCache(); */ allure.step(&quot;Disable proxy cache&quot;); this._checkProxy(); LOG.info(&quot;Disabling proxy cache...&quot;); if (this.httpProxy) this.httpProxy.useCache = false; if (this.globalProxy) this.globalProxy.useCache = false; LOG.info(&quot;Proxy cache is disabled&quot;); allure.pass(); return true; }, /** * Helper to check that proxy is launched. * * @ignore * @method * @protected * @instance * @throws {AssertionError} - If no one proxy is launched. */ _checkProxy: function () { expect( (this.httpProxy &amp;&amp; this.httpProxy.isRunning) || (this.globalProxy &amp;&amp; this.globalProxy.isRunning), &quot;No one proxy is launched&quot;).to.be.true; }, }; module.exports = ProxySteps; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Global Methods fxGlobalProxy(func) Fixture to launch http proxy. Parameters: Name Type Description func function Test funciton. Source: fixtures.js, line 36 fxHttpProxy(func) Fixture to launch http proxy. Parameters: Name Type Description func function Test funciton. Source: fixtures.js, line 15 interactive(cmd [, cli]) Interactive console. Parameters: Name Type Argument Description cmd Commands Commands instance. cli Vorpal &lt;optional&gt; Vorpal instance. Source: interactive.js, line 2 Returns: Configured Vorpal instance. Type Vorpal × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Modules Classes BaseProxy Commands GlobalProxy HttpProxy Mixins ProxySteps Namespaces GlaceConfig × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Classes Classes BaseProxy Commands GlobalProxy HttpProxy Mixins ProxySteps Namespaces GlaceConfig × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Namespaces Classes BaseProxy Commands GlobalProxy HttpProxy Mixins ProxySteps Namespaces GlaceConfig × Search results Close "},"mixins.list.html":{"id":"mixins.list.html","title":"Mixins","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Mixins Classes BaseProxy Commands GlobalProxy HttpProxy Mixins ProxySteps Namespaces GlaceConfig × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Tutorials Classes BaseProxy Commands GlobalProxy HttpProxy Mixins ProxySteps Namespaces GlaceConfig × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive | Source Code | Release Notes GlaceJS ProxyAnnotationGlaceJS proxy is nodejs interactive console application which launches http and global proxy to capture server responses and manage them. Features HTTP proxy launching Global transparent proxy launching Responses caching Responses speed management Chrome browser launching Interactive management Development and testing API InstallationBe sure that you have installed nodejs &gt;= v8.9. Or download and install it. npm i glacejs-proxyAfter installation utility glace-proxy will be available in terminal. Use glace-proxy -h to get details about its usage or see section Console Options. Installation for development: git clone https://github.com/schipiga/glacejs-proxy cd glacejs-proxy npm iQuick StartTo start proxy server call the command in terminal: glace-proxy [options]Or create file config.json and fill it with content: { &quot;global-proxy&quot;: true or false, &quot;global-proxy-port&quot;: &quot;&lt;port number&gt;&quot;, &quot;install-certificate&quot;: true, &quot;existing-cache&quot;: true, &quot;cache-folder&quot;: &quot;&lt;/path/to/cache/folder&gt;&quot;, &quot;url&quot;: &quot;&lt;URL&gt;&quot;, &quot;speed&quot;: 128 }And then just execute command in terminal: glace-proxyConsole OptionsConfiguration: -c, --config [config-path] - Path to JSON file with CLI arguments. Default is cwd/config.json (if it exists). --web-url &lt;URL&gt; - Proxied URL for HTTP proxy. Required if HTTP proxy is used. (Note! All options below are may be used in config.json, see section Quick Start.) Proxy: --http-proxy - Activate HTTP proxy. --proxy-port [port-number] - Port for HTTP proxy. Default is random. For example: --proxy-port 3000. --global-proxy - Activate transparent global proxy. --global-proxy-port [port-number] - Port for transparent global proxy. Default is random. For example: --global-proxy-port 3001. --install-certificate - Install global proxy certificate as trusted. Requires administrator permissions. Windows only! --speed &lt;value&gt; - Responses speed from proxy to client (browser), kb/s. Default is unlimited. For example: --speed 128. Cache: --cache - Cache server responses to disk. --existing-cache - Cache server responses to disk. Connect to existing cache if it exists. --cache-folder [folder-path] - Folder to cache server responses. Default is cwd/.proxy-cache. For example: --cache-folder /path/to/my/cache. Chrome: --chrome - Launch google chrome and open proxied URL there. Pristine profile will be used. --chrome-incognito - Launch google chrome in incognito mode. Log: --log [file-path] - Path to log file. Default is cwd/glace-proxy.log. For example: --log /path/to/glace-proxy/log. --stdout-log - Print log messages to stdout. Other: -h, --help - Show help. GlaceJS Proxy commandsCommands will be available after glace-proxy launching: url &lt;url&gt; - Set proxied URL. proxy start http - Start HTTP proxy. proxy start global - Start global proxy. proxy stop http - Stop HTTP proxy. proxy stop global - Stop global proxy. proxy restart http - Restart HTTP proxy. proxy restart global - Restart global proxy. proxy speed &lt;speed&gt; - Limit proxy speed, kb/s. proxy requests speed &lt;speed&gt; - Limit proxy requests speed, kb/s. proxy responses speed &lt;speed&gt; - Limit proxy responses speed, kb/s. proxy speed reset - Unlimit proxy speed. chrome - Launch google chrome browser. Pristine profile will be used each time. chrome close - Close google chrome browser. chrome restart - Restart google chrome browser. Pristine profile will be used each time. cache - Cache server responses to disk. Cached responses will be replayed by proxy. cache disable - Disable proxy cache. cache clear - Remove cached responses from storage. help [command...] - Provide help for a given command. exit - Exit application. Development APIvar glaceProxy = require(&quot;glacejs-proxy&quot;);More details about development and testing API here. GlaceJS Proxy pluginAs GlaceJS framework plugin it will be loaded automatically. Plugin CLI --http-proxy - Use http proxy. --http-proxy-port - Port for http proxy. Default is random. Incompatible with --slaves option. --global-proxy - Use transparent global proxy. Chromium browsers only. --global-proxy-port - Port for transparent global proxy. Default is random. Incompatible with --slaves option. --install-certificate - Install global proxy certificate as trusted. Requires administrator permissions. --cache - Enable middleware to cache proxy responses to disk. --existing-cache - Use existing cache if it exists. --reconnect - Number of proxy reconnects on request error. Default is 1. Plugin API config fixtures steps Test examplesSee integration tests in order to explore examples. Tests and quality Project tests report is here Code coverage report is here × Search results Close "},"BaseProxy.html":{"id":"BaseProxy.html","title":"Class: BaseProxy","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Class: BaseProxy BaseProxy &lt;abstract&gt; new BaseProxy( [opts]) Base proxy. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description speed number &lt;optional&gt; &lt;nullable&gt; null Proxy speed, kb/s. reqSpeed number &lt;optional&gt; &lt;nullable&gt; null Requests speed, kb/s. resSpeed number &lt;optional&gt; &lt;nullable&gt; null Responses speed, kb/s. useCache boolean &lt;optional&gt; false Flag to use cache middleware. reconnect number &lt;optional&gt; 0 Number of times reconnect to remote side, if it breaks connection. timeout timeout &lt;optional&gt; 60000 Time to wait remote side response, ms. port port &lt;optional&gt; 0 Port. Default is random. Source: baseProxy.js, line 3 Methods getPort() Gets port number. Source: baseProxy.js, line 45 Throws: If port number is not defined and will be chosen randomly. Type Error Returns: Proxy port number. Type number getResponsesData() Gets responses data. Source: baseProxy.js, line 96 measureResponses() Starts to measure responses and gather information of them. Source: baseProxy.js, line 80 resetSpeed() Resets proxy speed. Source: baseProxy.js, line 72 setSpeed(speed) Sets proxy speed. Parameters: Name Type Description speed number | object Proxy speed, kb/s. Properties Name Type Argument Description req number &lt;optional&gt; &lt;nullable&gt; Requests speed, kb/s. res number &lt;optional&gt; &lt;nullable&gt; Responses speed, kb/s. Source: baseProxy.js, line 59 start() Starts proxy. Source: baseProxy.js, line 105 stop() Stops proxy server. Source: baseProxy.js, line 113 unmeasureResponses() Disables responses measurement. Source: baseProxy.js, line 88 × Search results Close "},"Commands.html":{"id":"Commands.html","title":"Class: Commands","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Class: Commands Commands Aggregates commands to manage GlaceJS proxy. new Commands(config [, opts]) Creates commands instance. Parameters: Name Type Argument Description config object Commands config. opts object &lt;optional&gt; Commands options. Properties Name Type Argument Default Description logger function &lt;optional&gt; Commands logger. Default is system logger. colored boolean &lt;optional&gt; false Flag to use ANSI color in log message. GlobalProxy object &lt;optional&gt; Global proxy class. HttpProxy object &lt;optional&gt; HTTP proxy class. isRunning object &lt;optional&gt; Function to detect is process launched. Source: commands.js, line 2 Methods &lt;protected&gt; _checkProxy() Helper to check whether any proxy is launched. Source: commands.js, line 479 Returns: true if proxy exists and launched, false otherwise. Type boolean &lt;protected&gt; _chromeUrl() Helper to get URL to open in chrome browser. If HTTP proxy is launched, it will return proxy URL. Source: commands.js, line 505 Returns: URL to open chrome. Type string &lt;protected&gt; _isChromeLaunched() Helper to define whether chrome is launched. Source: commands.js, line 494 Returns: Type boolean &lt;protected&gt; _isGlobalProxyLaunched() Helper to define whether global proxy is running. Source: commands.js, line 534 Returns: Type boolean &lt;protected&gt; _isHttpProxyLaunched() Helper to define whether http proxy is running. Source: commands.js, line 524 Returns: Type boolean &lt;async&gt; clearProxyCache() Command to clear proxy cache. Source: commands.js, line 465 Returns: true when cache will be cleared. Type Promise.&lt;boolean&gt; &lt;async&gt; closeChrome() Command to close chrome browser. Source: commands.js, line 350 Returns: true if chrome browser was closed. false if command can't be executed. Causes to not close chrome browser: Chrome browser isn't launched yet. Type Promise.&lt;boolean&gt; &lt;async&gt; disableProxyCache() Command to disable proxy cache. Source: commands.js, line 447 Returns: true if proxy cache wasn't disabled. false if command can't be executed. Causes to not disable proxy cache: HTTP proxy isn't launched. Type Promise.&lt;boolean&gt; &lt;async&gt; enableProxyCache() Command to enable proxy cache. Source: commands.js, line 427 Returns: true if proxy cache wasn't enabled. false if command can't be executed. Causes to not enable proxy cache: HTTP proxy isn't launched. Type Promise.&lt;boolean&gt; &lt;async&gt; launchChrome( [opts]) Command to launch chrome browser. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description chromeOpts Array.&lt;string&gt; &lt;optional&gt; [] Chrome options list. Source: commands.js, line 266 Returns: true if chrome browser was launched. false if command can't be executed. Causes to not launch chrome browser: HTTP proxy isn't launched yet. Chrome browser is launched already. Type Promise.&lt;boolean&gt; &lt;async&gt; launchGlobalProxy() Command to launch global transparent proxy. Source: commands.js, line 173 Returns: true if global transparent proxy isn't launched. false if command can't be executed. Causes to not launch global transparent proxy: Global transparent proxy is launched already. Type Promise.&lt;boolean&gt; &lt;async&gt; launchHttpProxy() Command to launch HTTP proxy. Source: commands.js, line 79 Returns: true if HTTP proxy was launched. false if command can't be executed. Causes to not launch HTTP proxy: HTTP proxy is launched already. Proxied URL isn't specified. Type Promise.&lt;boolean&gt; &lt;async&gt; resetProxySpeed() Command to reset proxy speed. Source: commands.js, line 407 Returns: true if proxy speed was reset. false if command can't be executed. Causes to not reset proxy speed: HTTP proxy isn't launched. Type Promise.&lt;boolean&gt; &lt;async&gt; restartChrome() Command to restart chrome browser. Source: commands.js, line 372 Returns: true if chrome browser was restarted. false if command can't be executed. Causes to not restart chrome browser are the the same as for command to launch chrome browser. Type Promise.&lt;boolean&gt; &lt;async&gt; restartGlobalProxy() Command to restart global transparent proxy. Source: commands.js, line 249 Returns: true if global transparent proxy was restarted. false if command can't be executed. Causes to not restart global transparent proxy are the same as for command to launch global transparent proxy. Type Promise.&lt;boolean&gt; &lt;async&gt; restartHttpProxy() Command to restart HTTP proxy. Source: commands.js, line 158 Returns: true if HTTP proxy was restarted. false if command can't be executed. Causes to not restart HTTP proxy are the same as for command to launch HTTP proxy. Type Promise.&lt;boolean&gt; &lt;async&gt; setProxiedUrl() Command to set proxied URL. Source: commands.js, line 61 Returns: Type Promise &lt;async&gt; setProxySpeed(speed) Command to set proxy speed. Parameters: Name Type Description speed number Proxy speed, kb/s. Properties Name Type Argument Description req number &lt;optional&gt; &lt;nullable&gt; Requests speed, kb/s. res number &lt;optional&gt; &lt;nullable&gt; Responses speed, kb/s. Source: commands.js, line 387 Returns: true if proxy speed was set. false if command can't be executed. Causes to not set proxy speed: HTTP proxy isn't launched. Type Promise.&lt;boolean&gt; &lt;async&gt; stopGlobalProxy( [opts]) Command to stop global transparent proxy. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description restartChrome boolean &lt;optional&gt; true Restart chrome. Source: commands.js, line 223 Returns: true if global transparent proxy was stopped. false if command can't be executed. Causes to not stop global transparent proxy: Global transparent proxy isn't launched yet. Type Promise.&lt;boolean&gt; &lt;async&gt; stopHttpProxy( [opts]) Command to stop HTTP proxy. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Default Description restartChrome boolean &lt;optional&gt; true Restart chrome. Source: commands.js, line 133 Returns: true if HTTP proxy was stopped. false if command can't be executed. Causes to not stop HTTP proxy: HTTP proxy isn't launched yet. Type Promise.&lt;boolean&gt; × Search results Close "},"GlobalProxy.html":{"id":"GlobalProxy.html","title":"Class: GlobalProxy","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Class: GlobalProxy GlobalProxy Contains methods to run and manage global transparent proxy. new GlobalProxy( [opts]) Creates new instance of GlobalProxy. Parameters: Name Type Argument Description opts object &lt;optional&gt; global proxy options Properties Name Type Argument Default Description port number &lt;optional&gt; 0 global proxy port timeout number &lt;optional&gt; 0 global proxy timeout installCertificate boolean &lt;optional&gt; false flag to install global proxy certificate as trusted in order to manage https connection or no rootPath string &lt;optional&gt; &lt;nullable&gt; Folder where proxy starts in order to generate self-signed certificate. By default is current work directory. useCache boolean &lt;optional&gt; false flag to cache and take from cache responses Source: globalProxy.js, line 2 Methods &lt;async&gt; start() Starts global proxy if it's not started yet. Source: globalProxy.js, line 121 stop() Stops global proxy if it's not stopped yet. Source: globalProxy.js, line 168 × Search results Close "},"HttpProxy.html":{"id":"HttpProxy.html","title":"Class: HttpProxy","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Class: HttpProxy HttpProxy new HttpProxy(opts) HTTP Proxy. Parameters: Name Type Description opts object Proxy options. Properties Name Type Description url string URL which should be proxied. them from cache. Source: httpProxy.js, line 2 Methods setUrl(targetUrl) Sets proxied URL. Parameters: Name Type Description targetUrl string URL which should be proxied. Source: httpProxy.js, line 74 &lt;async&gt; start() Starts proxy server if it’s not started yet. Source: httpProxy.js, line 108 Returns: Proxy URL. Type Promise.&lt;string&gt; stop() Stops proxy server if it’s not stopped yet. Source: httpProxy.js, line 130 × Search results Close "},"module-cli.html":{"id":"module-cli.html","title":"Module: cli","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: cli GlaceJS proxy runner. Source: cli.js, line 2 Methods &lt;static&gt; run(cmd) Proxy runner. Parameters: Name Type Description cmd Commands Commands. Source: cli.js, line 22 Returns: Type Promise.&lt;void&gt; × Search results Close "},"module-config.html":{"id":"module-config.html","title":"Module: config","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: config Configures GlaceJS proxy before run. Source: config.js, line 2 Namespaces GlaceConfig × Search results Close "},"module-config-GlaceConfig.html":{"id":"module-config-GlaceConfig.html","title":"Namespace: GlaceConfig","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Namespace: GlaceConfig config~ GlaceConfig Contains GlaceJS proxy configuration. Properties: Name Type Argument Default Description url string &lt;optional&gt; &lt;nullable&gt; null Proxied URL. cache object Cache config. Properties Name Type Argument Default Description ttl number &lt;optional&gt; Time to life cache. Default is maximum. size number &lt;optional&gt; Maximum cached file size. Default is 10 GB. use boolean &lt;optional&gt; false Use cache. existing boolean &lt;optional&gt; false Use existing cache if exists. folder boolean &lt;optional&gt; cwd/.proxy-cache Cache folder. chrome object Chrome config. Properties Name Type Argument Default Description launch boolean &lt;optional&gt; false Launch chrome browser. incognito boolean &lt;optional&gt; false Use incognito mode in chrome. log object Log config. Properties Name Type Argument Default Description level string &lt;optional&gt; debug Log level. path string &lt;optional&gt; cwd/glace-proxy.log Log file path. stdout boolean &lt;optional&gt; false Print log messages to terminal. proxy object Proxy config. Properties Name Type Argument Default Description timeout number &lt;optional&gt; 60000 Proxy time to wait for remote response, ms. http number &lt;optional&gt; false Launch http proxy. port number &lt;optional&gt; 0 Proxy port. By default will be assigned by OS. global boolean &lt;optional&gt; false Launch global proxy. globalPort number &lt;optional&gt; 8888 Global proxy port. installCertificates boolean &lt;optional&gt; Install global proxy certificates as trusted. Windows only. Admin privileges are required. reconnect number &lt;optional&gt; 2 Number of reconnect attemptions if remote side breaks connection. Source: config.js, line 16 × Search results Close "},"module-fixtures.html":{"id":"module-fixtures.html","title":"Module: fixtures","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: fixtures Proxy fixtures. Source: fixtures.js, line 2 × Search results Close "},"module-help.html":{"id":"module-help.html","title":"Module: help","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: help Help description. Source: help.js, line 2 × Search results Close "},"module-index.html":{"id":"module-index.html","title":"Module: index","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: index GlaceJS proxy. Source: index.js, line 2 Members &lt;inner&gt; Commands :Commands Type: Commands Source: index.js, line 22 &lt;inner&gt; config :GlaceProxyConfig Type: GlaceProxyConfig Source: index.js, line 31 &lt;inner&gt; GlobalProxy :GlobalProxy Type: GlobalProxy Source: index.js, line 40 &lt;inner&gt; HttpProxy :HttpProxy Type: HttpProxy Source: index.js, line 49 &lt;inner&gt; interactive :interactive Type: interactive Source: index.js, line 58 &lt;inner&gt; pluginHelp :pluginHelp Type: pluginHelp Source: index.js, line 85 &lt;inner&gt; Steps :ProxySteps Type: ProxySteps Source: index.js, line 94 × Search results Close "},"module-middleware_cache.html":{"id":"module-middleware_cache.html","title":"Module: middleware/cache","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: middleware/cache Middleware to cache responses. Source: middleware/cache.js, line 2 Methods &lt;inner&gt; cache() Middleware to cache server responses and reply them. This: BaseProxy Source: middleware/cache.js, line 61 Returns: true if response was retrieved from cache, false otherwise. Type boolean &lt;inner&gt; fromCache(req, res) Patches http response to send response from cache, if it is there. Parameters: Name Type Description req object http(s) request res object http(s) response Source: middleware/cache.js, line 105 Returns: true if response is in cache and was patched, otherwise false Type Promise.&lt;boolean&gt; &lt;inner&gt; toCache(req, res) Patches http response to put response to cache. Parameters: Name Type Description req object http(s) request res object http(s) response Source: middleware/cache.js, line 132 × Search results Close "},"module-middleware_index.html":{"id":"module-middleware_index.html","title":"Module: middleware/index","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: middleware/index Proxy middlewares. Source: middleware/index.js, line 2 × Search results Close "},"module-middleware_info.html":{"id":"module-middleware_info.html","title":"Module: middleware/info","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: middleware/info Contains proxy middlewares Source: middleware/info.js, line 2 × Search results Close "},"module-middleware_reqBody.html":{"id":"module-middleware_reqBody.html","title":"Module: middleware/reqBody","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: middleware/reqBody Middleware to store request body. Source: middleware/reqBody.js, line 2 × Search results Close "},"module-middleware_resHead.html":{"id":"module-middleware_resHead.html","title":"Module: middleware/resHead","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: middleware/resHead Middleware to cache responses. Source: middleware/resHead.js, line 2 × Search results Close "},"module-middleware_speed.html":{"id":"module-middleware_speed.html","title":"Module: middleware/speed","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Module: middleware/speed Middleware to manage responses speed. Source: middleware/speed.js, line 2 × Search results Close "},"ProxySteps.html":{"id":"ProxySteps.html","title":"Mixin: ProxySteps","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Mixin: ProxySteps ProxySteps Steps to manage proxy. These methods are mixed with glacejs Steps class and available via its instance SS in tests. Properties: Name Type Description webUrl string Web application URL. globalProxy GlobalProxy Global proxy instance. httpProxy HttpProxy HTTP proxy instance. Source: steps.js, line 2 Methods disableCache() Step to disable cache. Source: steps.js, line 624 Returns: true if step is passed. Type boolean Example SS.disableCache(); enableCache() Step to enable cache. Source: steps.js, line 597 Returns: true if step is passed. Type boolean Example SS.enableCache(); getProxyUrl( [opts]) Step to get proxy URL. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that proxy URL is defined. Source: steps.js, line 126 Throws: If proxy URL isn't defined. Type AssertionError Returns: Proxy URL. Type string Example var proxiedUrl = SS.getProxiedUrl(); getResponsesData( [opts]) Step to get measured responses data. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that responses data are present. Source: steps.js, line 501 Throws: If responses data are absent. Type AssertionError Returns: List of captured response data. Type Array.&lt;object&gt; Example var responses = SS.getResponsesData(); limitProxySpeed(speed [, opts]) Step to limit proxy speed. Parameters: Name Type Argument Description speed number | object Proxy limited speed, kb/s. Properties Name Type Argument Description req number &lt;optional&gt; &lt;nullable&gt; Requests speed, kb/s. res number &lt;optional&gt; &lt;nullable&gt; Responses speed, kb/s. opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that proxy speed is limited. Source: steps.js, line 320 Throws: If proxy speed is not limited. Type AssertionError Returns: true if step was passed. Type boolean Example SS.limitProxySpeed(512); SS.limitProxySpeed({ res: 512 }); measureResponses( [opts]) Step to start responses measurement. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that responses measurement is launched. Source: steps.js, line 450 Throws: If responses measurement is not launched. Type AssertionError Returns: true if step is passed. Type boolean Example SS.measureResponses(); registerProxy( [opts]) Helper to register proxy classes. Parameters: Name Type Argument Description opts object &lt;optional&gt; Options. Properties Name Type Argument Description GlobalProxy object &lt;optional&gt; Global proxy class. HttpProxy object &lt;optional&gt; HTTP proxy class. Source: steps.js, line 33 Example SS.registerProxy({ GlobalProxy: MyGlobalProxy, HttpProxy: MyHttpProxy }); &lt;async&gt; startGlobalProxy( [opts]) Step to start global proxy. Step recall will be skipped if global proxy wasn't stopped before. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description useCache boolean &lt;optional&gt; Flag to use proxy cache for responses. Default value will be requested from config.useCache if it is specified. timeout number &lt;optional&gt; Proxy timeout to break connection. Default value will be requested from config.timeout.proxy. reconnect number &lt;optional&gt; Number of proxy reconnects on failure. port number &lt;optional&gt; Proxy port. Default value will be requested from config.globalProxyPort. check boolean &lt;optional&gt; true Flag to check that proxy was launched. Source: steps.js, line 207 Throws: If global proxy was not launched. Type AssertionError Returns: true if step was passed, false if was skipped. Type Promise.&lt;boolean&gt; Example await SS.startGlobalProxy(); await SS.startGlobalProxy({ timeout: 30000 }); &lt;async&gt; startHttpProxy( [opts]) Step to start HTTP proxy. Step recall will be skipped if proxy wasn't stopped before. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description webUrl string &lt;optional&gt; Web application url which will be proxied. Default value will be requested from config.web.url if it is specified. useCache boolean &lt;optional&gt; Flag to use proxy cache for responses. Default value will be requested from config.useCache if it is specified. timeout number &lt;optional&gt; Proxy timeout to break connection. Default value will be requested from config.timeout.proxy. reconnect number &lt;optional&gt; Number of proxy reconnects on failure. port number &lt;optional&gt; Proxy port. Default value will be requested from config.proxyPort. check boolean &lt;optional&gt; true Flag to check that proxy was launched. Source: steps.js, line 53 Throws: If proxy was not launched. Type AssertionError Returns: Proxied URL. Type Promise.&lt;string&gt; false if step was skipped Type Promise.&lt;boolean&gt; Example var proxiedUrl = await SS.startHttpProxy(); var proxiedUrl = await SS.startHttpProxy({ webUrl: &quot;http://example.com&quot;, }); var proxiedUrl = await SS.startHttpProxy({ webUrl: &quot;http://example.com&quot;, port: 8080 }); &lt;async&gt; stopGlobalProxy( [opts]) Step to stop global proxy. Step call will be skipped if global proxy wasn't launched before. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that global proxy was stopped. Source: steps.js, line 275 Throws: If global proxy wasn't stopped. Type AssertionError Returns: true if step was passed, false if was skipped. Type Promise.&lt;boolean&gt; Example await SS.stopGlobalProxy(); &lt;async&gt; stopHttpProxy( [opts]) Step to stop HTTP proxy. Step call will be skipped if proxy wasn't launched before. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that proxy was stopped. Source: steps.js, line 160 Throws: If proxy wasn't stopped. Type AssertionError Returns: true if step was passed, false if was skipped. Type Promise.&lt;boolean&gt; Example await SS.stopHttpProxy(); unlimitProxySpeed( [opts]) Step to unlimit proxy speed. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that proxy speed is unlimited. Source: steps.js, line 393 Throws: If proxy speed is still limited. Type AssertionError Returns: true if step is passed. Type boolean Example SS.unlimitProxySpeed(); unmeasureResponses( [opts]) Step to stop responses measurement. Parameters: Name Type Argument Description opts object &lt;optional&gt; Step options. Properties Name Type Argument Default Description check boolean &lt;optional&gt; true Flag to check that responses measurement is stopped. Source: steps.js, line 546 Throws: If responses measurement is still running. Type AssertionError Returns: true if step is passed. Type boolean Example SS.unmeasureResponses(); × Search results Close "},"tutorial-release-notes.html":{"id":"tutorial-release-notes.html","title":"Tutorial: Release Notes","body":" GlaceJS Namespaces config~GlaceConfig Modules cliconfigfixtureshelpindexmiddleware/cachemiddleware/indexmiddleware/infomiddleware/reqBodymiddleware/resHeadmiddleware/speed Classes BaseProxyCommandsGlobalProxyHttpProxy Mixins ProxySteps Tutorials Release Notes Global fxGlobalProxyfxHttpProxyinteractive Release Notes v1.3.6 Started to support slaves mechanism. v1.3.5 Choose global proxy port randomly by default. v1.3.4 Updated dependencies. v1.3.3 Added allure steps. v1.3.2 Changed logging level for cache. Fixed bug that ctx can be null on mitm proxy error. v1.3.1 Restore web url after stop HTTP proxy. v1.3.0 Added project workflow commands. Expanded plugin help. Logged steps. v1.2.9 Used docstring style in steps. v1.2.8 Added feature to manage requests and responses proxy speed separately and together. v1.2.7 Fixed bug that on reconnect http proxy didn't use proxy options. v1.2.6 Fixed typo in help: use --web-url CLI option instead of wrong --url. v1.2.5 Chrome is restarted if any proxy is stopped and it was launched. Ability to pass custom chrome options in command to launch chrome. Multiple fixes of bugs found by unit and e2e tests. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
